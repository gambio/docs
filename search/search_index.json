{"config":{"lang":["de"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"ADRs/","title":"We are going to create architectural decision records","text":"<p>Created: 2019-11-28 by Mirko</p> <p>Status: accepted</p> <p>Decision makers: Moritz, Daniel Wu</p>"},{"location":"ADRs/#context","title":"Context","text":"<p>Sometimes it is hard to remember why certain decisions where made and in which context. Additional it is also difficult to find specific information about architectural systems and how we things should be done correctly.</p> <p>In context of refactoring the core system of the shop, there are many decisions that need to be done and it seems very important to find a good way to communicate these decisions with the whole team. That's why it seems like a good idea to introduce architectural decision records (ADR).</p> <p>Here a short overview about the topic. An architectural decision (AD) is a design decision considering the architecture of the software, that addresses architecturally significant requirements. An architecture decision record (ADR) is a document that captures an important architectural decision made along with its context and consequences. An architecture decision log (ADL) is the collection of all ADRs created and maintained for a particular project (or organization).</p> <p>More information can be found on wikipedia or here.</p>"},{"location":"ADRs/#decision","title":"Decision","text":"<p>We are going to create architectural decision records based on this template for every architectural decision. Everyone will be allowed to create and propose new ADRs. New ADRs will be created to propose changes to existing ADRs.</p> <p>After a AD has been accepted, the ADR status will be changed and everyone at Gambio, that is developing for the shop software, will mind these decisions and follow them.</p> <p>If a AD has been rejected or if it is deprecated, that status of the ADR will also be updated and a short text about it will be added to the ADR.</p> <p>For each new proposed ADR a Bitrix post will be created for the \"Entwicklung (Core)\" group, so that every developer will be notified and there is the possibility to discuss certain ADs, even if the decision itself will be done by the deciders.</p> <p>The latest ADRs will always be in the latest feature development branch of the shop software.</p>"},{"location":"ADRs/#consequences","title":"Consequences","text":"<p>Positive:</p> <ul> <li>It will be easier to find/remember architectural decisions, that have been made in the past</li> <li>Architectural decisions should be more comprehensible</li> <li>Information about how to solve/implement certain architectural problems/components can be found easier</li> <li>The documentation of this software will be become better</li> </ul> <p>Negative:</p> <ul> <li>Making architectural decisions will more time consuming</li> </ul>"},{"location":"ADRs/002-rest_api/","title":"Following a specific concept for the new REST API v3","text":"<p>Created: 2019-11-29 by Mirko</p> <p>Status: accepted</p> <p>Decision makers: Daniel Wu, Moritz, Wilken</p> <p>Last updated: 2022-01-21 by Mirko</p>"},{"location":"ADRs/002-rest_api/#context","title":"Context","text":"<p>Currently, we are serving a REST API v2 with the shop software, which contains many endpoint for certain shop entities etc. But it is noticeable, that some endpoint following different rules or concept than others. Furthermore, the current API v2 dynamically determines the needed HTTP Controller based on the URL and don't use internal routing maps.</p> <p>Because of these and more quirks, it's hard to implement new features or change existing endpoints. Therefore, we need a new version of the REST API!</p> <p>For creating a new version of the REST API it seems useful to setup a specific concept that should be use for planning or implementing new API v3 endpoints.</p> <p>The decision in this ADR is based on best practices and internal discussions as well as external requirements from ERP systems.</p> <p>The use of GraphQL has also been part of the discussion, but didn't fit in our current requirements (see Consequences).</p>"},{"location":"ADRs/002-rest_api/#decision","title":"Decision","text":"<p>We are documenting every API endpoint by using the OpenAPI v2 specification.</p> <p>An example of some well documented endpoints can be found here.</p>"},{"location":"ADRs/002-rest_api/#naming-of-routes","title":"Naming of routes","text":"<p>While naming the routes, the endpoints are be grouped if the handle the same resources and plural forms are used. E.q. <code>/api.php/v3/customers</code> contains every endpoints using the customer resources. Read, add, edit and delete actions are encapsulated as HTTP methods (see \"Request methods\"). The resource routes should be as flat as possible.</p>"},{"location":"ADRs/002-rest_api/#request-methods","title":"Request methods","text":"<p>We are using the following request methods like:</p> <ul> <li><code>GET</code> is used to fetch a list or a specific document. <code>GET /api.php/v3/customers</code> will return a list of customers.</li> <li><code>POST</code> is used to create one or more documents. <code>POST /api.php/v3/customers</code> will create on or more customers.</li> <li><code>PUT</code> is used to update one or more documents. <code>PUT /api.php/v3/customers</code> will update on or more customers and   <code>PUT /api.php/v3/customers/1</code> will update the customer with the ID 1.</li> <li><code>PATCH</code> is used to patch one or more documents. <code>PATCH /api.php/v3/customers</code> will patch on or more customers and   <code>PATCH /api.php/v3/customers/1</code> will patch the customer with the ID 1.</li> <li><code>DELETE</code> is used to delete one or more documents. <code>DELETE /api.php/v3/customers/1</code> will delete the customer with the   ID 1 and <code>DELETE /api.php/v3/customers/1,2,3</code> will delete the customers with the ID 1, ID 2 and ID 3.</li> </ul> <p>We are especially using <code>POST</code> for creating documents, because of bulk requests. Otherwise the client could mix create and update actions in one request.</p> <p><code>PATCH</code> endpoint are optional. A new domain does't need to have these functionality and should only be implemented, if there is a real use case.</p>"},{"location":"ADRs/002-rest_api/#status-codes","title":"Status codes","text":"<p>We are using the following status codes for responses like:</p> <ul> <li>General<ul> <li><code>403</code> is used, if the requesting client isn't authorized.</li> <li><code>500</code> is used for unexpected errors.</li> </ul> </li> <li><code>GET</code><ul> <li><code>200</code> is used for successful requests.</li> <li><code>404</code> is used, if a specific document doesn't exist.</li> </ul> </li> <li><code>POST</code><ul> <li><code>201</code> is used for successful create requests.</li> <li><code>400</code> is used, if the data in the request body are incomplete or malformed.</li> <li><code>409</code> is used, if a conflict of data exists, even with valid information. E.q. a customer already exists with the   same email address and it is not allowed to have two customers with the same email address.</li> <li><code>422</code> is used, if the data in the request body are okay, but invalid.</li> </ul> </li> <li><code>PUT</code><ul> <li><code>204</code> is used for successful update requests.</li> <li><code>400</code> is used, if the data in the request body are incomplete or malformed.</li> <li><code>404</code> is used, if the document that should be updated doesn't exist.</li> <li><code>409</code> is used, if a conflict of data exists, even with valid information. E.q. a customer already exists with the   same email address and it is not allowed to have two customers with the same email address.</li> <li><code>422</code> is used, if the data in the request body are okay, but invalid.</li> </ul> </li> <li><code>PATCH</code><ul> <li><code>204</code> is used for successful patch requests.</li> <li><code>400</code> is used, if the data in the request body are incomplete or malformed.</li> <li><code>404</code> is used, if the document that should be patched doesn't exist.</li> <li><code>409</code> is used, if a conflict of data exists, even with valid information. E.q. a customer already exists with the   same email address and it is not allowed to have two customers with the same email address.</li> <li><code>422</code> is used, if the data in the request body are okay, but invalid.</li> </ul> </li> <li><code>DELETE</code><ul> <li><code>204</code> is used for successful delete requests.</li> </ul> </li> </ul> <p>Error handling and validation should be done as complete as possible to provided as many error information as possible. E.q. should a 422 error result contain information about every invalid attribute in the provided request body.</p> <p>The <code>DELETE</code> response will also return an <code>204</code> status code, even if the document with the provided ID does not exit.</p>"},{"location":"ADRs/002-rest_api/#responses","title":"Responses","text":"<p>All API response have the <code>application/json</code> content type and must always contain the following HTTP headers:</p> <ul> <li><code>X-Shop-Version</code> contains the current shop version.</li> <li><code>X-API-Version</code> contains the current REST API version.</li> <li><code>X-Rate-Limit-Limit</code> contains the request limit per hour.</li> <li><code>X-Rate-Limit-Remaining</code> contains the remaining request for the current time frame.</li> <li><code>X-Rate-Limit-Reset</code> contains the number of seconds til the current rate limit will be reset.</li> </ul> <p>The listed HTTP headers are just the minimum set of headers, depending the endpoint it's possible to add additional HTTP headers.</p> <p>Links will be part of the response body and should be added to the <code>_meta</code> attribute, depending on the executed request. E.q. a link to a specific customer resource inside the response body of a specific orders document.</p> <p>The response body of a successful request is always enveloped, and contain an attribute <code>data</code> with the result data and an attribute <code>_meta</code> for meta information:</p> <pre><code>{\n    \"data\": {\n        ...\n    },\n    \"_meta\": {\n        ...\n    }\n}\n</code></pre> <p>The response body of a failed request is always enveloped, and contain an attribute <code>errors</code> with information about the errors and an attribute <code>_meta</code> for meta information:</p> <pre><code>{\n    \"errors\": {\n        ...\n    },\n    \"_meta\": {\n        ...\n    }\n}\n</code></pre> <p>The response for a create, update or patch request don't contain the complete documents on success. The response of a create request will contain a link and the ID of the created document. The response of a update, patch or delete request should contain no response body and have a 204 status code.</p> <p>A <code>GET</code> endpoint that will return a collection of documents can be customized by the following query parameters:</p> <ul> <li><code>per-page</code> is used to change the number of documents, that will be returned per page.</li> <li><code>page</code> is used for pagination and changes the page of a collection, that will be returned.</li> <li><code>fields</code> is used to filter the attributes of the documents, that will be returned. The <code>fields</code> parameter always   contains document attributes and never database column etc.</li> <li><code>sort</code> is used to sort the documents, that will be returned. The <code>sort</code> parameter always contains a comma seperated   list of the document attributes. A <code>+</code> (ascending) or <code>-</code> (descending) at the beginning of a attribute can be used   modify the order. If no specific order is provided than a ascending order should be used.</li> <li><code>filter</code> is used to filter the documents, that will be returned, based on the provided rules. The <code>filter</code> parameter   is always an array, which maps a specific filter pattern to a document attribute. The filtering on string attributes   must allow wildcards (<code>*</code> character) and be case insensitive. The API must also provided the possibility to use   operations like greater (gt), greater equals (gte), less (lt), less equals (lte) for numeric or datetime attributes.   If no operation is provided, it will be handled as an equals operation. The operation must be part of the value and   can be added before the filter pattern, like the following examples show:<ul> <li><code>GET /api.php/v3/customers?filter[firstName]=John</code> will return all customers with first name \"John\".</li> <li><code>GET /api.php/v3/customers?filter[firstName]=J*</code> will return all customers whose first name begins with \"J\".</li> <li><code>GET /api.php/v3/customers?filter[firstName]=J*&amp;filter[id]=*1</code> will return all customers whose first name begins   with \"J\" and whose ID will end with an one.</li> <li><code>GET /api.php/v3/customers?filter[id]=gt|42</code> will return all customers whose ID is greater than 42.</li> <li><code>GET /api.php/v3/customers?filter[id]=gte|42</code> will return all customers whose ID is equals or greater than 42.</li> <li><code>GET /api.php/v3/customers?filter[id]=lt|42</code> will return all customers whose ID is less than 42.</li> <li><code>GET /api.php/v3/customers?filter[id]=lte|42</code> will return all customers whose ID is equals or less than 42.</li> <li><code>GET /api.php/v3/customers?filter[id]=neq|42</code> will return all customers whose ID is not equal to 42.</li> <li><code>GET /api.php/v3/customers?filter[id]=eq|42</code> or <code>GET /api.php/v3/customers?filter[id]=42</code> will return the customer   with the ID 42.</li> </ul> </li> </ul> <p>A <code>GET</code> endpoint that will return a collection of documents does always provided pagination links inside the <code>_meta</code> attribute, as well as additional meta information about the total number of documents, the current per-page and page, like:</p> <pre><code>{\n    \"data\": [\n        ...\n    ],\n    \"_meta\": {\n        \"totalItems\": 145,\n        \"page\": 3,\n        \"perPage\": 25,\n        \"links\": {\n            \"firstPage\": \"/api.php/v3/customers?page=1\",\n            \"previousPage\": \"/api.php/v3/customers?page=2\",\n            \"nextPage\": \"/api.php/v3/customers?page=4\",\n            \"lastPage\": \"/api.php/v3/customers?page=5\"\n        }\n    }\n}\n</code></pre> <p>The response of a <code>GET</code> endpoint, that will return a collection of documents, is always enveloped and does always provide meta information about the total number of documents, the current page and per-page values. (Additional meta information are possible.)</p>"},{"location":"ADRs/002-rest_api/#bulk-requests","title":"Bulk requests","text":"<p>In general, we are implementing endpoints for bulk request and only don't, if there is a good reason not to do this.</p> <p>Bulk requests are implemented for creating and updating documents and will be have the same route like the base route for requesting a collection of documents, e.q. <code>POST /api.php/v3/customers</code> or <code>PUT /api.php/v3/customers</code>.</p> <p>For the bulk delete request we will accept a comma-separated list of IDs of documents, that should be deleted, as path parameter like: <code>DELETE /api.php/v3/customers/1,2,3</code></p> <p>Bulk request are handled as one transaction, if a single create, update, patch or delete fails, then there will be a rollback.</p> <p>The request body for bulk creation and updates should always be a simple JSON array. The keys of this array should be used for the response body. In case of a successful action, e.q. the ID of the created document can be mapped to this key. In case of an error, e.q. the errors can be mapped to this key. This way the client can still identify which created ID or which error belongs to which document.</p> <p>Please have in mind, that a PHP array is only also a JSON array, if its keys are consecutive numbers starting at 0.</p>"},{"location":"ADRs/002-rest_api/#links-as-meta-information","title":"Links as meta information","text":"<p>Every REST API responses should provide links as meta information as far as possible. These could be links to newly created entities or related ones. We should attempt to link our resources as tightly as possible, which means that:</p> <ul> <li>Sub-resources should link their main resources if possible.   E.g. <code>GET /api.php/v3/customers/{customerId}/memos/{memoId}</code> should link to <code>GET /api.php/v3/customers/{customerId}</code></li> <li>Resources should link to related resources even if there might be no data, as long as an empty collection will be   returned.   E.g. <code>GET /api.php/v3/customers/{customerId}</code> should link to <code>GET /api.php/v3/customers/{customerId}/memos</code> even   though there are no actual memos for that customer.</li> <li>The <code>links</code> array as part of the <code>_meta</code> block of the response should always be a map and have a descriptive key for   their related links.</li> </ul>"},{"location":"ADRs/002-rest_api/#consequences","title":"Consequences","text":"<p>We won't use GraphQL for creating a new web API, because we want to focus on creating stable endpoint and domain services, instead focusing on a new technology. A further reason why we choose REST instead of GraphQL, is a simple cost-benefit calculation: We don't thing, that there is a big need for a web API based on GraphQL. Furthermore, the API v3 will be more likely an additional API for the existing v2 API and not a fully covering shop API. Currently, it is more likely that a future v4 API will be based on GraphQL.</p> <p>We introduced a general attribute for meta information and envelop every response body. Furthermore, we handle bulk request as one and will use transactions that can be rolled back. This will probably increase the effort of implementing a new endpoint, but also improve the use- and accessibility.</p> <p>We also want to write the API documentation first and test our API endpoint against this documentation to improve the completeness and timeliness of the documentation.</p> <p>It's likely that these rules will need an update in the future, after we implemented some new endpoints.</p>"},{"location":"ADRs/002-rest_api/#updates","title":"Updates","text":""},{"location":"ADRs/002-rest_api/#request-body-of-bulk-request-should-always-be-a-json-array-2020-07-30","title":"Request body of bulk request should always be a JSON array (2020-07-30)","text":"<p>Currently, it's too hard to handle JSON arrays and objects as a request body for bulk requests simultaneously. That's why we (Toby, Moritz, and Mirko) decided that the request body of a bulk request should be a JSON array.</p> <p>This way, it's easier to define a schema for the OpenAPI specifications, and it's also easier to parse the request body with PHP.</p>"},{"location":"ADRs/002-rest_api/#added-new-example-request-for-filter-2021-08-11","title":"Added new example request for filter (2021-08-11)","text":"<p>The new endpoints for the REST API v3 should also support the <code>neq</code> operator, that's why I added it to the filter sample requests.</p>"},{"location":"ADRs/002-rest_api/#added-new-section-about-linking-resources-2022-01-21","title":"Added new section about linking resources (2022-01-21)","text":"<p>The new section <code>Links as meta information</code> was added to emphasize the importance of linking related resources.</p>"},{"location":"ADRs/003-rules_conventions_and_conding_standards/","title":"Rules and coding standards for clean, less verbose and concise code","text":"<p>Created: 2020-03-12 by Mirko</p> <p>Status: accepted</p> <p>Decision makers: Moritz, Daniel W., Tobias S., Mirko</p> <p>Last updated: 2021-04-01 by Mirko</p>"},{"location":"ADRs/003-rules_conventions_and_conding_standards/#context","title":"Context","text":"<p>With the usage of the new architecture in GX 4, we noticed that there are different ways how we name and use classes, interfaces, and namespaces in general. To make sure the new refactored systems follow some consistent rules, we discussed some naming conventions. To go even further, we also want to define some general and already known coding standards, that had been used over the last years.</p> <p>The starting point for this was the previous pool in Bitrix about the interface suffix as well as the following articles we read:</p> <ul> <li>https://verraes.net/2013/09/sensible-interfaces/</li> <li>https://medium.com/@Claromentis/naming-classes-interfaces-and-namespaces-361c63474e6c</li> <li>https://www.nikolaposa.in.rs/blog/2019/01/06/better-naming-convention/</li> </ul>"},{"location":"ADRs/003-rules_conventions_and_conding_standards/#decision","title":"Decision","text":"<p>While working inside the shop project, we follow the following rules and standards.</p>"},{"location":"ADRs/003-rules_conventions_and_conding_standards/#rules","title":"Rules","text":"<ul> <li>We always use strict comparisons.</li> <li>We always add <code>declare(strict_types=1)</code> at the beginning of a file.</li> <li>We use parentheses when creating new instances, even if they do not require arguments (<code>$foo = new Foo();</code>).</li> <li>All developers using this coding style to reformat before committing their source code into the version control   system. Old legacy files don't have to be reformatted completely, because the differences of the commits would be too   much.</li> <li>We name classes as specific as possible. There shouldn't be any classes like <code>Reader</code>, <code>Writer</code> etc. even if they   might be unique inside their domain or namespace. Example: In general, we prefer classes like<code>\\Store\\Warehouse\\XmlWarehouse</code> or <code>\\Store\\Warehouse\\WarehouseXml</code>   instead of <code>\\Store\\Warehouse\\Xml</code>.</li> <li>We don't use the <code>get</code> prefix for getters in entities and value objects. Example: If there is a method that provides e.g. the first name, then it should be named <code>firstName</code>.</li> <li>Instead of using the <code>set</code> prefix for setters in entities and value objects, we give the methods a more meaningful   name like e.g. <code>updateOrder</code>, <code>changeSorting</code>, or <code>replaceDescription</code> in context of the domain.</li> <li>We keep the nesting of control structures per method as small as possible. An example can be found   here.</li> <li>We exit as early as possible instead of nesting conditions or using else statements. An example can be found   here.</li> <li>We don't create or use magic numbers; we create constant or variables to specify these numbers and giving them more   context.</li> <li>We add PHPDoc blocks that contain at least information about parameters, exceptions and the return value.</li> <li>We name events in past tense and don't add an <code>Event</code> suffix.</li> <li>Exceptions keep their <code>Exception</code> suffix, but should also be named as specific as possible. It's also a good idea to   implement meaningful static construct methods like   <code>throw CustomerCreationFailedException::becauseOfPreviousError($previousException);</code> or.   <code>throw CustomerDoesNotExistException::forId($customerId);</code>.</li> <li>We keep methods and classes as simple/stupid as possible. Simpler is always better. Reduce complexity as much as   possible.</li> <li>Interfaces don't have an <code>Interface</code> suffix. Therefore, they should be named as generic as possible and the   implemented classes as specific as possible. Classes with the same name as the interface they are implementing should   be a rare exception. Because of the interface segregation principle, it's recommended to create multiple interfaces   with generic names and combine them.</li> <li>When writing unit tests we focus on testing the behaviour of the classes. Therefore, we don't write tests for   service provider and it's ok to skip unit tests for low level value objects.</li> <li>Instead of creating unit tests for controllers or actions, we focus on integration tests for these classes.</li> </ul>"},{"location":"ADRs/003-rules_conventions_and_conding_standards/#general-standards-and-conventions","title":"General standards and conventions","text":"<ul> <li>We follow the SOLID principles.</li> <li>We use Domain-driven design to model our domains.</li> <li>We mind the requirements for running the shop software like minimum and maximum versions or needed extensions.</li> </ul>"},{"location":"ADRs/003-rules_conventions_and_conding_standards/#recommendations","title":"Recommendations","text":"<ul> <li>It's better to implement a <code>toArray</code> method than the <code>JsonSerializable</code> interface, because this allows a more direct   access to the data of a class. Furthermore, no <code>json_decode(json_encode(...))</code> hacks are needed and the objects don't   make the impression that they can be deserialized easily.</li> <li>Some exceptions don't need to be part of the documentation (e.g. PHPDoc) because they aren't relevant. Good examples   for this are the Doctrine exceptions that will be thrown by certain methods, when there is no DB connection or a   rollback should be done without a started transaction. These exceptions aren't relevant for the documentation of a   domain.</li> <li>When implementing a collection, we need to be careful about which interfaces we are using. It's not recommended using   the <code>ArrayAccess</code> interface for value objects in general, because this makes them mutable. There it's better to use   the <code>IteratorAggregate</code> interface instead.</li> </ul>"},{"location":"ADRs/003-rules_conventions_and_conding_standards/#consequences","title":"Consequences","text":"<p>These rules will increase the consistency of the source code and will make it easier for developers (external as well as internal) to understand and work with it. By removing the <code>Interface</code> and <code>Event</code> suffix, we also remove tautologies (saying the same thing twice), that are common in our everyday language.</p>"},{"location":"ADRs/003-rules_conventions_and_conding_standards/#updates","title":"Updates","text":""},{"location":"ADRs/003-rules_conventions_and_conding_standards/#completely-reworked-proposed-and-not-accepted-adr-2020-09-18","title":"Completely reworked proposed and not accepted ADR (2020-09-18)","text":"<p>The purpose of this ADR had been changed so that it focuses more on general coding guidelines instead of how to name classes and interfaces. At this point, the ADR wasn't accepted (just proposed), so that there are no changes to be explicitly enumerated.</p>"},{"location":"ADRs/003-rules_conventions_and_conding_standards/#completely-reworked-proposed-and-not-accepted-adr-2020-04-01","title":"Completely reworked proposed and not accepted ADR (2020-04-01)","text":"<p>Added new recommendations regarding the usage of some PHP specific interfaces and restructured the content to separate rules, recommendations, and standards more.</p>"},{"location":"ADRs/004-inner-structure-of-architecture/","title":"The inner structure of the new architecture","text":"<p>Created: 2020-08-14 by Mirko</p> <p>Status: accepted</p> <p>Decision makers: Moritz, Daniel W., Tobias S., Mirko</p>"},{"location":"ADRs/004-inner-structure-of-architecture/#context","title":"Context","text":"<p>While starting the refactoring of the shop software, we also started to create a new architecture for the shop software. While in the refactoring process, we didn't know how the architecture should look or what we need at a certain point, we can now describe it very well. Therefore, the following part will give an overview of how we want to structure the architecture.</p> <p>Describing this structure, we orientated ourselves on Martin Fowler's clean architecture and other models like onion or hexagonal architectures. For us, it was an essential detail that domain-driven design should be visible clearly.</p>"},{"location":"ADRs/004-inner-structure-of-architecture/#decision","title":"Decision","text":"<p>The new (GX4) architecture of the shop software includes four layers. Each layer should only interact with its neighbors, and the inner layer shouldn't require any knowledge about the outer layers. As shown in the picture below, we have the Framework, Application Core, Use Cases, and the Domain Model as separate layers.</p> <p></p>"},{"location":"ADRs/004-inner-structure-of-architecture/#framework","title":"Framework","text":"<p>The framework layer includes general tools and components to execute the shop software. It contains no specific business logic that can't tell you anything about the exact functionality of this software, but it provides the framework for running the software. This layer will include elements that handle, for example, incoming HTTP requests, logging, session, or the database connection.</p>"},{"location":"ADRs/004-inner-structure-of-architecture/#application-core","title":"Application Core","text":"<p>Deeper in the application core layer, the components execute certain main functionalities of the application. The tasks performed here are still very technical and far away from specific business rules. Parts of this layer are controllers or actions for the incoming HTTP requests, application services, or database readers and writers.</p>"},{"location":"ADRs/004-inner-structure-of-architecture/#use-cases","title":"Use Cases","text":"<p>The (domain-driven design) domain starts with the layer for the use cases. The entirety of domains show what this application is about; therefore, this layer provides information about the use cases and possibilities of interacting with these domains. Domain service, interfaces of repositories, and factories are typical components of this layer.</p>"},{"location":"ADRs/004-inner-structure-of-architecture/#domain-model","title":"Domain Model","text":"<p>When using domain-driven design, the model is a fundamental part of the software because it contains the business logic of the whole software. But this is also the part that is less volatile than the outer parts of the software. The components of this layer are entities, value objects, events, and the aggregate root.</p>"},{"location":"ADRs/004-inner-structure-of-architecture/#consequences","title":"Consequences","text":"<p>Following this, the architecture limits the usage of components of different layers; for instance, it's not possible to directly use a logger and database connection inside the domain. Therefore, a favorable outcome is that the maintainability of each component increases.</p> <p>In some cases, we bend some general recommendations, but we do this always to make the whole architecture as understandable and catchy as possible. So, for example, the factory is not part of the domain model, which it usually is in the domain-driven design. As something most likely providing the ability for data to go through boundaries, we put it also near the application services, which use these factories in general.</p>"},{"location":"ADRs/005-implementing-modules/","title":"Rules and best practices for implementing modules","text":"<p>Created: 2020-08-14 by Mirko</p> <p>Status: accepted</p> <p>Decision makers: Moritz, Daniel W., Tobias S., Mirko</p> <p>Last updated: 2021-04-01 by Mirko</p>"},{"location":"ADRs/005-implementing-modules/#context","title":"Context","text":"<p>We tried different ideas and patterns for implementing modules in the past, but not all of these improved the quality or usability of these modules. Therefore, and because of consistency, we needed a general ruleset and collection of best practices of how to implement modules, domains, and application services for the GX shop software.</p> <p>The following decisions are based on the ADR \"004 - The inner structure of the new\" architecture about the shop architecture structure, so it would be wise to read this ADR first.</p>"},{"location":"ADRs/005-implementing-modules/#decision","title":"Decision","text":""},{"location":"ADRs/005-implementing-modules/#file-based-module-structure","title":"File-based module structure","text":"<p>The file and directory structure of a module separates components of different architecture layers and features. The following example shows this kind of separation:</p> <pre><code>GambioAdmin/\n    - Modules/\n        - Example/\n            - ExampleServiceProvider.php\n            - routes.php\n            - ui/\n                - assets/\n                - templates/\n            - App/                                        [Application Core]\n                - Actions/\n                    - ExampleAction.php\n                - CommandHandlers/\n                - Data/\n                    - ExampleMapper.php\n                    - ExampleReader.php\n                    - ExampleRepository.php\n                    - ExampleWriter.php\n                - EventHandlers/\n                - Exceptions/\n                    - SomethingNeedsToBeHandledInTheRepositoryException.php\n                - ExampleApplicationService.php\n            - Model/                                      [Domain Model]\n                - Collections/\n                - Entities/\n                - Events/\n                    - ExampleCreated.php\n                    - ExampleDeleted.php\n                    - ExamplePartUpdated.php\n                - Exceptions/\n                    - BrokeABusinessRuleException.php\n                - Interfaces/\n                - ValueObjects/\n                - ExampleAggregateRoot.php\n            - Services/                                   [Use Cases / Domain Services]\n                - Exceptions/\n                    - CreationFailedException.php\n                    - StorageFailedException.php\n                    - DeletionFailedException.php\n                - ExampleDomainService.php\n                - ExampleFactory.php\n                - ExampleRepositoryInterface.php\n                - ExampleApplicationServiceInterface.php\n            - Support/                                    [Framework]\n                - ExampleHelper.php\n                - ExampleClient.php\n</code></pre> <p>As you can see, the first directories (<code>App</code>, <code>Support</code>, <code>Model</code>, and <code>Services</code>) separating the Application Services, Framework, Domain Model, and Domain Services/Use Cases layer of the module. An additional directory named <code>ui</code> contains all UI specific content.</p>"},{"location":"ADRs/005-implementing-modules/#implementing-a-module","title":"Implementing a module","text":"<ul> <li>New routes will be defined using a <code>routes.php</code> file in the base directory of the module.</li> <li>Components and services of a module are defined using a Service Provider, which also must be inside the module's   base directory.</li> <li>UI components like templates and assets (JS and SCSS) have to be inside the <code>ui</code> directory. The <code>ui/templates</code>   directory contains the templates, while the <code>ui/assets</code> directory contains the assets. All assets are build based   on a <code>ui/assets/index.ts</code> file that will be processed by Webpack.</li> </ul>"},{"location":"ADRs/005-implementing-modules/#implementing-a-domain","title":"Implementing a domain","text":"<ul> <li>We use domain-driven design for modeling new domains and focus on creating rich domain models (or as rich as   possible) in context of the use-cases of the domain.</li> <li>Writing the documentation does have priority and should start at the beginning (or even before implementing the   domain).</li> <li>Use cases of a domain result in meaningful events that will be raised by the aggregate root or the repository (in   case of creation or deletion).</li> <li>Implementing an ID for an entity, you should not use ambivalent values. In general, it's a positive integer or   string corresponding to a value in the database. It shouldn't be that value or <code>null</code>, because this makes it   harder to handle the IDs.</li> <li>To store new entities, you use the factory for the creation and add them to the aggregate root. To create a new   aggregate root,  you need to provide the necessary information to the repository, which then creates, stores, and   returns them.</li> <li>A service, implemented to interact with a domain comfortably, should rely on primitive types for   arguments as far as possible. We call these classes application services, and they are entirely different   from domain services in domain-driven design.</li> <li>Each domain should have at least one application service, designed on the use cases of that domain. Use   cases of the aggregate root should not be part of these services.</li> <li>We separate components that read and write into data sources like a MySQL database or a file on the server, which   is also justified by the single responsibility principle.</li> <li>The repository uses a mapper class to map data from the reader and writer components to domain objects.</li> <li>Domain objects should not implement the <code>JsonSerializable</code> interface.</li> <li>Value objects like collection should not implement the <code>ArrayAccess</code> interface.</li> </ul> <p>The image below shows the model of an example domain:</p> <p></p>"},{"location":"ADRs/005-implementing-modules/#implementing-an-application-service","title":"Implementing an application service","text":"<ul> <li>While handling language-dependent data, it's comfortable to use the two-digit ISO code instead of the language ID.   So whenever a service needs an identifier for a language, the two-digit ISO code should be applied.</li> <li>We keep domain objects near the domain and don't transfer them outside an application service that requested them.   If the domain data need to be provided as a response (e.q. for an incoming HTTP or API request), we use DTOs or   serialization to uncouple the data from the domain object.</li> <li>We use HTTP actions instead of HTTP controllers because it's better to handle a single request in a component   instead of multiple requests. The single responsibility principle also justifies this.</li> </ul>"},{"location":"ADRs/005-implementing-modules/#consequences","title":"Consequences","text":"<p>These rules and decisions come with a few consequences. The positive ones are that in general, the implementation of new modules, domains, and application services will become more consistent and easier to understand. Another positive consequence might be that we can set up conventions instead of configurations, which means that we can automatically process files that match a specified pattern instead of changing configuration files.</p> <p>Besides these positive consequences, there is also a negative one: Smaller or medium-size modules might have components, where some argue are not necessary or too much, but it all helps to improve the consistency and comprehensibility of these modules.</p>"},{"location":"ADRs/005-implementing-modules/#updates","title":"Updates","text":""},{"location":"ADRs/005-implementing-modules/#completely-reworked-proposed-and-not-accepted-adr-2020-04-01","title":"Completely reworked proposed and not accepted ADR (2020-04-01)","text":"<p>Added new rules and extended the example directory structure.</p>"},{"location":"ADRs/006-naming-version-receipts/","title":"Naming of version receipts","text":"<p>Created: 2020-09-04 by Moritz Bunjes</p> <p>Status: accepted</p> <p>Decision makers: Moritz, Daniel W., Tobias S., Alexandros, Timo, Mirko</p>"},{"location":"ADRs/006-naming-version-receipts/#context","title":"Context","text":"<p>The shop system itself as well as extensions for it put a version receipt as a PHP file in the \"src/version_info\"  folder. For this file no naming convention has been defined so far, so that there are many different variants for  naming. Other software and tools use these receipts to determine what state a shop is in. In order for such software  to better understand these files, fixed naming rules should be defined.</p>"},{"location":"ADRs/006-naming-version-receipts/#decision","title":"Decision","text":"<p>The name should consist of two to three parts: 1. The package name 2. The package version 3. An optional specification</p> <p>The format is the following: <code>&lt;package-name&gt;_&lt;package-version&gt;[_&lt;optional-specification&gt;].php</code></p> <p>Each part can use these characters: <code>a-z</code>, <code>0-9</code>, <code>-</code>, <code>.</code></p> <p>The filename can be verified by this regular expression: <code>^(?&lt;package_name&gt;[a-z0-9-.]+)_(?&lt;package_version&gt;[a-z0-9-.]+)(?:(_(?&lt;optional_specification&gt;[a-z0-9-.]+))?).php?</code></p> <p>Example: <code>gambio-hub_1.18.0_gx3.9.1.x-3.12.3.0.php</code></p>"},{"location":"ADRs/006-naming-version-receipts/#consequences","title":"Consequences","text":"<p>In the future we will have a uniform format that we can rely on, so that we can work technically easier and faster.  The disadvantage is that there is a break with old, previously undefined conventions, so that the format changes for  some shop packages. In addition, systems that read out version receipts, such as the Gambio Hub, have to be adapted  accordingly, but at the same time must still be able to cope with old receipts.</p>"},{"location":"ADRs/007-handling-of-prices/","title":"Handling of prices","text":"<p>Created: 2021-11-11 by Mirko Janssen</p> <p>Status: accepted</p> <p>Decision makers: Moritz, Mirko</p>"},{"location":"ADRs/007-handling-of-prices/#context","title":"Context","text":"<p>When it comes to prices and handling numbers used for that purpose, we should mind some pitfalls and best practices. In the shop software, we are often handling different types of prices, and inside all sorts of different domains; therefore, it's important to have similar rules of handling them.</p>"},{"location":"ADRs/007-handling-of-prices/#decision","title":"Decision","text":"<ul> <li>We always store prices and numbers used for price calculation with at least four decimal places.</li> <li>When storing prices and numbers used for price calculation, we ensure that the context to which they belong is clear   and meaningful. It should always be clear based on the context if a price is net or gross, additional documentation   may also help.</li> <li>As long as it's not clear what kind of tax rate is used for calculating taxes for a given price, the price is always   stored as a net price. Otherwise, the gross price can be stored together with information about the tax rates it's   based on.</li> </ul>"},{"location":"ADRs/008-gambio-admin-submodules/","title":"Support for submodules in the GambioAdmin","text":"<p>Created: 2022-07-26 by Tobias Schindler | Marvin Muxfeld</p> <p>Status: draft</p> <p>Decision makers: to be completed</p>"},{"location":"ADRs/008-gambio-admin-submodules/#context","title":"Context","text":"<p>For the version Gambio GX4 we have developed a new application core, which has since been used for the development of new shop components. For this, we have set up rules in ADR 004 and ADR 005. Over time the new directory <code>GambioAdmin/Modules</code> has grown more and more, and we noticed that often several modules are created to map the function of a domain.</p> <p>To solve both problems we thought about supporting so-called \"Submodules\" in GambioAdmin. With submodules, it should be possible to go one level deeper within a module to better group the functions.</p> <p>For example, currently (07/26/2022) there are three product-related modules in GambioAdmin: <code>ProductOption</code> , <code>ProductVariant</code>, and <code>ProductDownload</code>.</p>"},{"location":"ADRs/008-gambio-admin-submodules/#decision","title":"Decision","text":"<p>After applying the new rules for submodules, inside the <code>GambioAdmin/Modules</code> directory, there would be a new directory  called <code>Product</code>, which is the main module for products. Three more directories named <code>Option</code>, <code>Variant</code>, and <code>Download</code> would be stored inside a directory called <code>Submodules</code>, which is created on the top level of the main module.</p> <p>Submodules need to follow the same structure and rules as the main module (ADR 004 and ADR 005). Only difference  between a main module and a submodule is that it can't contain additional submodule's</p> <pre><code>Before ADR 008\n- GambioAdmin/\n    - Modules/\n        - ProductOption/\n        - ProductVariant/\n        - ProductDownload/\n\nAfter ADR 008\n- GambioAdmin/\n    - Modules/\n        - Product/\n            - Submodules/\n                - Option/\n                - Variant/\n                - Download/\n</code></pre>"},{"location":"ADRs/008-gambio-admin-submodules/#service-provider-and-routes","title":"Service provider and routes","text":"<p>Submodules can have their service provider and routes.php files. A bootstrapper is responsible for loading the files. Thus, it is possible to implement a whole section of a certain domain within a submodule.</p>"},{"location":"ADRs/008-gambio-admin-submodules/#boundaries","title":"Boundaries","text":"<p>Software modularity is ensured by high cohesion and low coupling. To ensure low coupling, it is important to define boundaries for modules and submodules.</p> <p>We have the rule that modules communicate with each other only via application services. The rule remains as it is. It is not allowed to use the application services of a submodule outside the respective module. If functions implemented within a submodule are required in another module, an application service must be implemented in the main module to provide the required function.</p>"},{"location":"ADRs/008-gambio-admin-submodules/#consequences","title":"Consequences","text":"<p>The structure of the <code>GambioAdmin/Modules</code> directory should become much clearer by using submodules. This makes it possible to group the modules better and to maintain the system. However, it must be ensured using code reviews that the rules concerning the module boundaries are adhered to.</p>"},{"location":"ADRs/attachments/001-template/","title":"[Title: short present tense imperative phrase, less than 50 characters (at least try); like a git commit message]","text":"<p>Created: [date] by [proposer]</p> <p>Status: [proposed, accepted, rejected, deprecated, superseded, etc.]</p> <p>Decision makers: [list everyone involved in the decision]</p>"},{"location":"ADRs/attachments/001-template/#context","title":"Context","text":"<p>[what is the issue that we're seeing, that is motivating this decision or change? hard wrap at 120 characters]</p>"},{"location":"ADRs/attachments/001-template/#decision","title":"Decision","text":"<p>[what is the change, that we're actually proposing or doing. hard wrap at 120 characters]</p>"},{"location":"ADRs/attachments/001-template/#consequences","title":"Consequences","text":"<p>[that becomes easier or more difficult to do because of this change. hard wrap at 120 characters]</p>"},{"location":"CI/create-nightly-build/","title":"How to Set Up a Nightly Build for a Specific Branch","text":"<p>To configure a Nightly Build that runs every day at a specific time, follow these steps:</p> <ol> <li>Visit the pipeline schedules overview page: Pipeline Schedules</li> <li>Click on \"New schedule\"</li> <li>Provide a descriptive name for the schedule, indicating the purpose and the target branch for the Nightly Build.</li> <li>Specify the interval for the Nightly Build. Typically, it runs every day at night. However, you can use any cron syntax to customize the interval pattern. For assistance with the cron syntax, you can consult Crontab.guru</li> <li>Choose <code>GXCI_schedules</code> as the target branch for the Nightly Build.</li> <li>Add the following variables:<ul> <li>Key: <code>CI_SCHEDULE_ACTION</code>, Value: <code>build_nightly_version</code></li> <li>Key: <code>CI_SCHEDULE_BRANCH</code>, Value: <code>&lt;the target branch name&gt;</code></li> </ul> </li> <li>Click \"Save pipeline schedule\" to complete the setup.</li> </ol> <p>By following these steps, you'll have a Nightly Build set up for the specified branch, automatically running at the designated time every day.</p>"},{"location":"CI/create-nightly-build/#editing-the-pipeline-in-gitlab-ciyml","title":"Editing the Pipeline in <code>.gitlab-ci.yml</code>","text":"<p>To customize the Nightly Build pipeline, you need to edit the <code>.gitlab-ci.yml</code> file in the branch <code>GXCI_schedules</code>. Within the <code>.gitlab-ci.yml</code> file, locate the section titled \"Build nightly version\".</p> <p>In this section, you can define the specific tasks and steps that will be executed during the Nightly Build.</p> <p>Remember to commit and push your changes to the <code>GXCI_schedules</code> branch after editing the <code>.gitlab-ci.yml</code> file. The changes will take effect during the next scheduled Nightly Build.</p> <p>Make sure to test your changes thoroughly to ensure that the Nightly Build works as expected and meets your requirements.</p>"},{"location":"CI/create-nightly-build/#triggering-a-build-outside-the-interval","title":"Triggering a Build Outside the Interval","text":"<p>If you need to run a Nightly Build outside the predefined interval, GitLab allows you to take ownership of the schedule and manually trigger a build. Follow these steps:</p> <ol> <li>On the pipeline schedules page, locate your schedule and click the \"Take ownership\" button. (Note: This step is only required if you're not already the owner of the schedule.)</li> <li>Once you've taken ownership, a \"Play\" button will be available, allowing you to start a build immediately, regardless of the interval settings.</li> </ol> <p>Keep in mind that triggering a build manually can be helpful for testing purposes or urgent releases, but it's essential to use it judiciously to maintain the intended Nightly Build schedule.</p> <p>That's it! Now you have a Nightly Build scheduled for your branch, you can customize the build process by editing the <code>.gitlab-ci.yml</code> file and you can manually trigger a build.</p>"},{"location":"CI/nightwatch.js/","title":"Nightwatch.js Documentation","text":""},{"location":"CI/nightwatch.js/#how-to-run-nightwatchjs-tests-in-the-shop","title":"How to Run Nightwatch.js Tests in the Shop","text":"<p>When running a complete test suite using <code>yarn tests</code>, the Nightwatch.js tests will also be executed at the end. You can specifically trigger the Nightwatch.js tests using the <code>yarn tests:e2e</code> command.</p>"},{"location":"CI/nightwatch.js/#failing-ci-pipelines","title":"Failing CI Pipelines","text":""},{"location":"CI/nightwatch.js/#visual-regression-testing","title":"Visual Regression Testing","text":"<p>Error messages like:</p> <pre><code>Visual regression test results for element &lt;body&gt;... in 5000ms - expected \"true\" but got:\n\"/home/gitlab-runner/builds/e35e9b66/3/gambio/gxdev/tests/nightwatch/vrt/diff/store/categories/category_as_list.tablet.png\"\n</code></pre> <p>can be checked in the failed pipeline. To review, click the \"Download\" button in the \"Job artifacts\" section on the right sidebar.</p> <p></p> <p>After downloading the zip archive, extract its contents to a local web server. Inside the extracted files, there's a <code>test-results</code> directory containing results in txt format. If there were any failed Visual Regression Tests (VRT), you'll also find a <code>vrt</code> directory.</p> <p></p> <p>This page displays each VRT test. For each failed test, three screenshots are shown:</p> <p>1) The baseline image on the left for comparison. 2) A comparison image between images 1 and 3 in the middle. 3) The recently captured screenshot on the right.</p> <p>This page offers two additional functions:</p> <p>1) A \"Hide Successful Tests\" link to hide successful tests upon clicking. 2) A download link above the first test to download all recently captured screenshots of failed tests.</p>"},{"location":"CI/nightwatch.js/#the-file-permissions-must-be-set-to-0777-for-the-download-to-function","title":"the file permissions must be set to 0777 for the download to function","text":"<p>If the differences are intended changes, the downloaded screenshots can replace the baseline images in this repository. Baseline screenshots are stored in <code>tests/nightwatch/vrt/baseline</code>.</p>"},{"location":"CI/nightwatch.js/#end-to-end-e2e-testing","title":"End-to-End (E2E) Testing","text":"<p>If regular E2E tests are failing, they can also be executed locally. To do this, adjust the <code>nightwatch.conf.js</code> (<code>tests/nightwatch/nightwatch.conf.js</code>) file.</p> <p></p> <p>Removing the <code>\"--headless\",</code> argument will launch a Chrome window during test execution, allowing observation of the test progress.</p>"},{"location":"CI/nightwatch.js/#most-likely-the-vrt-tests-will-fail-locally-temporarily-deleting-the-testsnightwatchvrtbaseline-directory-will-resolve-this","title":"Most likely, the VRT tests will fail locally; temporarily deleting the <code>tests/nightwatch/vrt/baseline</code> directory will resolve this.","text":""},{"location":"CI/nightwatch.js/#execution-with-different-resolutions","title":"Execution with different resolutions","text":"<p>Every test is initially executed for the \"desktop\" resolution. After these tests are run, all tests with the \"vrt\" tag are executed for all other resolutions as well.</p>"},{"location":"CI/nightwatch.js/#tags","title":"Tags","text":"<p>Tests in Nightwatch.js can be tagged with four categories: 1) <code>setup</code>: Executes once at the start, usually installing payment and shipping modules. 2) <code>admin</code>: Tests parts of the shop under <code>/admin</code>. 3) <code>store</code>: Tests parts of the store front 4) <code>vrt</code>: Visual Regression Tests.</p>"},{"location":"CI/nightwatch.js/#these-tags-are-set-in-each-individual-test-case-class","title":"these tags are set in each individual test case class","text":"<p>tests are located at <code>tests/nightwatch/tests</code></p>"},{"location":"CI/nightwatch.js/#resolutions","title":"Resolutions","text":"<p>1) desktop (1920x1080) 2) desktop-small (1680x1050) 3) desktop-large (2560x1080) 4) mobile (414x900) 5) tablet (1024x1366)</p>"},{"location":"REST/","title":"REST API documentation","text":"<p>This directory contains the specifications to build the API documentation of the Gambio REST API. The build process is based on OPEN API v3 specifications, an HTML/CSS/JS template, and some external Node modules included by Yarn.</p> <p>The OpenAPI v3 specifications are split into several files, which isn't of the OpenAPI v3 standard but allows better handling for a high number of endpoints. Therefore, the separate files need to be merged, so that the tool that generates the documentation can process the specification correctly.</p> <p>As you can see, the <code>[v2|v3]/openapi.json</code> uses JSON references to include additional content of other JSON or YAML files. The Node module <code>json-refs</code> merges the content (or resolving the references to external files) and creates the <code>[v2|v3]/resolved.openapi.json</code> file, which is used by the Node module <code>redoc-cli</code> to generate the documentation. The documentation is not only based on the content of the OpenAPI v3 specification, a template located at <code>./template</code> is used by the Redoc CLI tool and defines the look of the generated web page.</p> <p>Note: Each JSON file can be replaced with a YAML files (and the other way around). For the merging CLI tool it doesn't matter, if a JSON or YAML file is referenced.</p>"},{"location":"REST/#structure-of-the-specification-folder","title":"Structure of the specification folder","text":"<p>As said, the specification is split into several files, which can be found in the <code>[v2|v3]</code> directory. The sub-directories mirrors the structure of the OpenAPI v3 standard based on the <code>[v2|v3]/openapi.json</code> file.</p> <ul> <li> <p><code>[v2|v3]/components</code>   This directory contains definitions of parts of the request and response body, as well as the HTTP header. The   internal structure of the OpenAPI v3 standard is strictly mirrored in this directory. The contained <code>index.json</code>   files are used to structure the other JSON/YAML files in the same directory or the directories below.</p> </li> <li> <p><code>[v2|v3]/paths</code>   This directory contains the files that define the several API endpoints. The <code>[v2|v3]/paths/index.json</code> file   defines the URLs and references the corresponding HTTP methods. The contained <code>index.json</code> inside the sub-directories   (e.g. <code>[v2|v3]/paths/parcel-services/index.json</code>) maps a specific HTTP method with the json files, that defines   the endpoint specifications.</p> </li> <li> <p><code>[v2|v3]/tags</code>   This directory contains the tags. Each group of API endpoints have a specific tag. E.g. all endpoints starting with   <code>api.php/v3/parcel-service</code> belong to the tag parcel service and the files <code>[v2|v3]/tags/parcelServices.json</code>.   It's also possible to add additional tags to the specification to provide additional information, like its done   with the <code>[v2|v3]/tags/generalInformation.yaml</code> file. The tag files need to be referenced in the   <code>[v2|v3]/openapi.json</code> file.</p> </li> </ul>"},{"location":"REST/#how-to-define-a-new-api-endpoint","title":"How to define a new API endpoint","text":"<p>At first, you need to understand the OpenAPI v3 standard. It's similar to the v2 standard, that is used to define the Gambio REST API v2 endpoints, but doesn't match one-to-one.</p> <p>To define the structure of the request and response body, you need to define their schemas by creating new files and a new sub-directory inside <code>[v2|v3]/components/schemas</code> (similar to the existing schemas). References to other schema files can and should be used. After adding the new schemas, you need to add them to the <code>[v2|v3]/components/schemas/index.json</code> as well. The assigned JSON key is later used to reference the schemas in the definition files for the endpoints. E.g. the reference <code>#/components/schemas/trackingCodes-trackingCode</code> would reference the schema defined in <code>[v2|v3]/components/schemas/trackingCodes/trackingCode.json</code>.</p> <p>To define new HTTP endpoints, you need to define their schemas by creating new files and new sub-directories inside <code>[v2|v3]/paths</code>. References to other schema files are also possible, but you should use the internal references (e.g. <code>#/components/schemas/trackingCodes-trackingCode</code>) to reference schemas for response and request bodies, etc. After adding the new schemas, you need to add them to the <code>[v2|v3]/paths/index.json</code> as well.</p>"}]}